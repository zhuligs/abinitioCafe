#!/usr/bin/python -u

import numpy as np
import os
import math


def readvaspphon(nat):
    nbline = 4 + (3 + nat) * nat * 3
    os.system('grep "Eigenvectors after division by SQRT" -A ' +
              str(nbline) + ' OUTCAR > pbuff')
    buff = []
    with open('pbuff') as f:
        for line in f:
            buff.append(line)

    eigen = []
    freq = []
    it = 6
    for imode in range(nat * 3):
        ib = it + 2
        ie = ib + nat
        # print imode, it
        # print buff[it]
        freq.append(buff[it].split('=')[1].split()[0])
        eig = [x.split()[3:] for x in buff[ib:ie]]
        eigen.append(eig)
        it = ie + 1
    return np.array(freq, float), np.array(eigen, float)


def readposcar():
    buff = []
    with open('POSCAR') as f:
        for line in f:
            buff.append(line.split())
    symb = buff[5]
    typt = np.array(buff[6], int)
    nat = sum(typt)
    lat = np.array(buff[2:5], float)
    cons = lat2lcons(lat)
    nlat = lcons2lat(cons)
    pos = np.array(buff[8:8 + nat], float)
    rxyz = np.dot(pos, nlat)
    symbs = []
    for i in range(len(typt)):
        for j in range(typt[i]):
            symbs.append(symb[i])
    return nat, nlat, rxyz, symbs


def lat2lcons(lat):
    ra = math.sqrt(lat[0][0]**2 + lat[0][1]**2 + lat[0][2]**2)
    rb = math.sqrt(lat[1][0]**2 + lat[1][1]**2 + lat[1][2]**2)
    rc = math.sqrt(lat[2][0]**2 + lat[2][1]**2 + lat[2][2]**2)

    cosa = (lat[1][0] * lat[2][0] + lat[1][1] * lat[2][1] +
            lat[1][2] * lat[2][2]) / rb / rc
    cosb = (lat[0][0] * lat[2][0] + lat[0][1] * lat[2][1] +
            lat[0][2] * lat[2][2]) / ra / rc
    cosc = (lat[0][0] * lat[1][0] + lat[0][1] * lat[1][1] +
            lat[0][2] * lat[1][2]) / rb / ra

    alpha = math.acos(cosa)
    beta = math.acos(cosb)
    gamma = math.acos(cosc)

    return np.array([ra, rb, rc, alpha, beta, gamma], float)


def lcons2lat(cons):
    (a, b, c, alpha, beta, gamma) = cons

    bc2 = b**2 + c**2 - 2 * b * c * math.cos(alpha)

    h1 = a
    h2 = b * math.cos(gamma)
    h3 = b * math.sin(gamma)
    h4 = c * math.cos(beta)
    h5 = ((h2 - h4)**2 + h3**2 + c**2 - h4**2 - bc2) / (2 * h3)
    h6 = math.sqrt(c**2 - h4**2 - h5**2)

    lattice = [[h1, 0., 0.], [h2, h3, 0.], [h4, h5, h6]]
    return np.array(lattice, float)


def main():
    nat, lat, rxyz, symbs = readposcar()
    freq, eigen = readvaspphon(nat)
    # print freq
    f = open('vaspphon.ascii', 'w')
    f.write("# phon anime generated by vpm.py\n")
    f.write("%15.9f  %15.9f  %15.9f\n" % (lat[0][0], lat[1][0], lat[1][1]))
    f.write("%15.9f  %15.9f  %15.9f\n" % (lat[2][0], lat[2][1], lat[2][2]))
    for i in range(nat):
        f.write("%15.9f  %15.9f  %15.9f  %2s\n" %
                (rxyz[i][0], rxyz[i][1], rxyz[i][2], symbs[i]))
    nmode = nat * 3
    for i in range(nmode - 1, -1, -1):
        f.write("#metaData: qpt=[0.000000;0.000000;0.000000; %g \\ \n" % freq[i])
        for iat in range(nat):
            f.write("#;  %g;  %g;  %g; 0.000000;0.000000;0.000000 \\ \n" % tuple(eigen[i][iat]))
        f.write("# ]\n")
    f.close()

    f = open('vaspphon.xyz', 'w')
    for i in range(nmode - 1, -1, -1):
        f.write(str(nat * 8) + '\n')
        f.write("generated by vpm.py\n")
        for iat in range(nat):
            for ix in range(2):
                for iy in range(2):
                    for iz in range(2):
                        x1 = rxyz[iat][0] + ix * lat[0][0] + iy * lat[1][0] + iz * lat[2][0]
                        x2 = rxyz[iat][1] + ix * lat[0][1] + iy * lat[1][1] + iz * lat[2][1]
                        x3 = rxyz[iat][2] + ix * lat[0][2] + iy * lat[1][2] + iz * lat[2][2]
                        f.write("%s  %9.6f %9.6f %9.6f %9.6f %9.6f %9.6f\n"
                                % (symbs[iat], x1, x2, x3, eigen[i][iat][0]*5, eigen[i][iat][1]*5, eigen[i][iat][2]*5))
    f.close()


if __name__ == '__main__':
    main()


















